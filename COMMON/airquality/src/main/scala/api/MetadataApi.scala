/**
 * Umweltbundesamt Air Data API
 * Air data API of Umweltbundesamt
 *
 * OpenAPI spec version: 2.0.1
 * Contact: immission@uba.de
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package api

import java.text.SimpleDateFormat
import io.swagger.client.model.inline_response_200_3
import io.swagger.client.model.inline_response_200_5
import io.swagger.client.model.inline_response_200_7
import io.swagger.client.model.network
import io.swagger.client.model.stationsetting
import io.swagger.client.model.stationtype
import io.swagger.client.model.threshold
import io.swagger.client.model.transgressiontype
import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType
import java.io.File
import java.util.Date
import java.util.TimeZone
import scala.collection.mutable.HashMap
import com.wordnik.swagger.client._

import scala.concurrent.Future
import collection.mutable
import java.net.URI
import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}
import org.json4s._

class MetadataApi(
  val defBasePath: String = "https://www.umweltbundesamt.de/api/air_data/v2",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new MetadataApiAsyncHelper(client, config)

  /**
   * Get all components
   * This entry point returns a list of all components.
   *
   * @param lang The language code (optional, default to en)
   * @param index The type of index to be used (optional, default to id)
   * @return inline_response_200_3
   */
  def componentsJsonGet(lang: Option[String] = Option("en"), index: Option[String] = Option(id)): Option[inline_response_200_3] = {
    val await = Try(Await.result(componentsJsonGetAsync(lang, index), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all components asynchronously
   * This entry point returns a list of all components.
   *
   * @param lang The language code (optional, default to en)
   * @param index The type of index to be used (optional, default to id)
   * @return Future(inline_response_200_3)
   */
  def componentsJsonGetAsync(lang: Option[String] = Option("en"), index: Option[String] = Option(id)): Future[inline_response_200_3] = {
      helper.componentsJsonGet(lang, index)
  }

  /**
   * Get combined metadata for use
   * The use parameter defines what meta data should be returned. E.g. if you set use to airquality, meta data of airquality is returned.
   *
   * @param use Defines the use. 
   * @param lang The language code (optional, default to en)
   * @param dateFrom A date (required only for use &#x3D; airquality) (optional)
   * @param dateTo A date (required only for use &#x3D; airquality) (optional)
   * @param timeFrom An hour. (optional)
   * @param timeTo An hour. (optional)
   * @return inline_response_200_7
   */
  def metaJsonGet(use: String, lang: Option[String] = Option("en"), dateFrom: Option[String] = None, dateTo: Option[String] = None, timeFrom: Option[Integer] = None, timeTo: Option[Integer] = None): Option[inline_response_200_7] = {
    val await = Try(Await.result(metaJsonGetAsync(use, lang, dateFrom, dateTo, timeFrom, timeTo), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get combined metadata for use asynchronously
   * The use parameter defines what meta data should be returned. E.g. if you set use to airquality, meta data of airquality is returned.
   *
   * @param use Defines the use. 
   * @param lang The language code (optional, default to en)
   * @param dateFrom A date (required only for use &#x3D; airquality) (optional)
   * @param dateTo A date (required only for use &#x3D; airquality) (optional)
   * @param timeFrom An hour. (optional)
   * @param timeTo An hour. (optional)
   * @return Future(inline_response_200_7)
   */
  def metaJsonGetAsync(use: String, lang: Option[String] = Option("en"), dateFrom: Option[String] = None, dateTo: Option[String] = None, timeFrom: Option[Integer] = None, timeTo: Option[Integer] = None): Future[inline_response_200_7] = {
      helper.metaJsonGet(use, lang, dateFrom, dateTo, timeFrom, timeTo)
  }

  /**
   * Get all networks
   * This entry point returns a list of all networks.
   *
   * @param lang The language code (optional, default to en)
   * @param index The type of index to be used (optional, default to id)
   * @return List[network]
   */
  def networksJsonGet(lang: Option[String] = Option("en"), index: Option[String] = Option(id)): Option[List[network]] = {
    val await = Try(Await.result(networksJsonGetAsync(lang, index), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all networks asynchronously
   * This entry point returns a list of all networks.
   *
   * @param lang The language code (optional, default to en)
   * @param index The type of index to be used (optional, default to id)
   * @return Future(List[network])
   */
  def networksJsonGetAsync(lang: Option[String] = Option("en"), index: Option[String] = Option(id)): Future[List[network]] = {
      helper.networksJsonGet(lang, index)
  }

  /**
   * Get all scopes
   * The entry point returns a list of all scopes.
   *
   * @param lang The language code (optional, default to en)
   * @param index The type of index to be used (optional, default to id)
   * @return inline_response_200_5
   */
  def scopesJsonGet(lang: Option[String] = Option("en"), index: Option[String] = Option(id)): Option[inline_response_200_5] = {
    val await = Try(Await.result(scopesJsonGetAsync(lang, index), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all scopes asynchronously
   * The entry point returns a list of all scopes.
   *
   * @param lang The language code (optional, default to en)
   * @param index The type of index to be used (optional, default to id)
   * @return Future(inline_response_200_5)
   */
  def scopesJsonGetAsync(lang: Option[String] = Option("en"), index: Option[String] = Option(id)): Future[inline_response_200_5] = {
      helper.scopesJsonGet(lang, index)
  }

  /**
   * Get all station settings
   * This entry point returns a list of all station settings.
   *
   * @param lang The language code (optional, default to en)
   * @return List[stationsetting]
   */
  def stationsettingsJsonGet(lang: Option[String] = Option("en")): Option[List[stationsetting]] = {
    val await = Try(Await.result(stationsettingsJsonGetAsync(lang), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all station settings asynchronously
   * This entry point returns a list of all station settings.
   *
   * @param lang The language code (optional, default to en)
   * @return Future(List[stationsetting])
   */
  def stationsettingsJsonGetAsync(lang: Option[String] = Option("en")): Future[List[stationsetting]] = {
      helper.stationsettingsJsonGet(lang)
  }

  /**
   * Get all station types
   * This entry point returns a list of all station types.
   *
   * @param lang The language code (optional, default to en)
   * @return List[stationtype]
   */
  def stationtypesJsonGet(lang: Option[String] = Option("en")): Option[List[stationtype]] = {
    val await = Try(Await.result(stationtypesJsonGetAsync(lang), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all station types asynchronously
   * This entry point returns a list of all station types.
   *
   * @param lang The language code (optional, default to en)
   * @return Future(List[stationtype])
   */
  def stationtypesJsonGetAsync(lang: Option[String] = Option("en")): Future[List[stationtype]] = {
      helper.stationtypesJsonGet(lang)
  }

  /**
   * Get all thresholds
   * This entry point returns a list of all thresholds
   *
   * @param use Defines which thresholds to use. 
   * @param lang The language code (optional, default to en)
   * @param component Id of component (optional)
   * @param scope Id of scope (optional)
   * @return List[threshold]
   */
  def thresholdsJsonGet(use: String, lang: Option[String] = Option("en"), component: Option[Integer] = None, scope: Option[Integer] = None): Option[List[threshold]] = {
    val await = Try(Await.result(thresholdsJsonGetAsync(use, lang, component, scope), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all thresholds asynchronously
   * This entry point returns a list of all thresholds
   *
   * @param use Defines which thresholds to use. 
   * @param lang The language code (optional, default to en)
   * @param component Id of component (optional)
   * @param scope Id of scope (optional)
   * @return Future(List[threshold])
   */
  def thresholdsJsonGetAsync(use: String, lang: Option[String] = Option("en"), component: Option[Integer] = None, scope: Option[Integer] = None): Future[List[threshold]] = {
      helper.thresholdsJsonGet(use, lang, component, scope)
  }

  /**
   * Get all exceedances types
   * Returns all exceedances types
   *
   * @param lang The language code (optional, default to en)
   * @return List[transgressiontype]
   */
  def transgressiontypesJsonGet(lang: Option[String] = Option("en")): Option[List[transgressiontype]] = {
    val await = Try(Await.result(transgressiontypesJsonGetAsync(lang), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all exceedances types asynchronously
   * Returns all exceedances types
   *
   * @param lang The language code (optional, default to en)
   * @return Future(List[transgressiontype])
   */
  def transgressiontypesJsonGetAsync(lang: Option[String] = Option("en")): Future[List[transgressiontype]] = {
      helper.transgressiontypesJsonGet(lang)
  }

}

class MetadataApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def componentsJsonGet(lang: Option[String] = Option("en"),
    index: Option[String] = Option(id)
    )(implicit reader: ClientResponseReader[inline_response_200_3]): Future[inline_response_200_3] = {
    // create path and map variables
    val path = (addFmt("/components/json"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    lang match {
      case Some(param) => queryParams += "lang" -> param.toString
      case _ => queryParams
    }
    index match {
      case Some(param) => queryParams += "index" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def metaJsonGet(use: String,
    lang: Option[String] = Option("en"),
    dateFrom: Option[String] = None,
    dateTo: Option[String] = None,
    timeFrom: Option[Integer] = None,
    timeTo: Option[Integer] = None
    )(implicit reader: ClientResponseReader[inline_response_200_7]): Future[inline_response_200_7] = {
    // create path and map variables
    val path = (addFmt("/meta/json"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (use == null) throw new Exception("Missing required parameter 'use' when calling MetadataApi->metaJsonGet")

    queryParams += "use" -> use.toString
    lang match {
      case Some(param) => queryParams += "lang" -> param.toString
      case _ => queryParams
    }
    dateFrom match {
      case Some(param) => queryParams += "date_from" -> param.toString
      case _ => queryParams
    }
    dateTo match {
      case Some(param) => queryParams += "date_to" -> param.toString
      case _ => queryParams
    }
    timeFrom match {
      case Some(param) => queryParams += "time_from" -> param.toString
      case _ => queryParams
    }
    timeTo match {
      case Some(param) => queryParams += "time_to" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def networksJsonGet(lang: Option[String] = Option("en"),
    index: Option[String] = Option(id)
    )(implicit reader: ClientResponseReader[List[network]]): Future[List[network]] = {
    // create path and map variables
    val path = (addFmt("/networks/json"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    lang match {
      case Some(param) => queryParams += "lang" -> param.toString
      case _ => queryParams
    }
    index match {
      case Some(param) => queryParams += "index" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def scopesJsonGet(lang: Option[String] = Option("en"),
    index: Option[String] = Option(id)
    )(implicit reader: ClientResponseReader[inline_response_200_5]): Future[inline_response_200_5] = {
    // create path and map variables
    val path = (addFmt("/scopes/json"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    lang match {
      case Some(param) => queryParams += "lang" -> param.toString
      case _ => queryParams
    }
    index match {
      case Some(param) => queryParams += "index" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def stationsettingsJsonGet(lang: Option[String] = Option("en")
    )(implicit reader: ClientResponseReader[List[stationsetting]]): Future[List[stationsetting]] = {
    // create path and map variables
    val path = (addFmt("/stationsettings/json"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    lang match {
      case Some(param) => queryParams += "lang" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def stationtypesJsonGet(lang: Option[String] = Option("en")
    )(implicit reader: ClientResponseReader[List[stationtype]]): Future[List[stationtype]] = {
    // create path and map variables
    val path = (addFmt("/stationtypes/json"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    lang match {
      case Some(param) => queryParams += "lang" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def thresholdsJsonGet(use: String,
    lang: Option[String] = Option("en"),
    component: Option[Integer] = None,
    scope: Option[Integer] = None
    )(implicit reader: ClientResponseReader[List[threshold]]): Future[List[threshold]] = {
    // create path and map variables
    val path = (addFmt("/thresholds/json"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (use == null) throw new Exception("Missing required parameter 'use' when calling MetadataApi->thresholdsJsonGet")

    queryParams += "use" -> use.toString
    lang match {
      case Some(param) => queryParams += "lang" -> param.toString
      case _ => queryParams
    }
    component match {
      case Some(param) => queryParams += "component" -> param.toString
      case _ => queryParams
    }
    scope match {
      case Some(param) => queryParams += "scope" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transgressiontypesJsonGet(lang: Option[String] = Option("en")
    )(implicit reader: ClientResponseReader[List[transgressiontype]]): Future[List[transgressiontype]] = {
    // create path and map variables
    val path = (addFmt("/transgressiontypes/json"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    lang match {
      case Some(param) => queryParams += "lang" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
